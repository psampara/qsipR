#Keep Feature and taxonomy columns only
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::select(Feature, Taxonomy)
#Create a tibble within the previous tibble to access abundances of each MAG in every sample
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
abs_abundance = purr::map(Feature, ~ dplyr::filter(long_cov, Feature == .) %>%
dplyr::select(Sample, Abundance))
)
#Populate the corresponding fraction, BD, Replicate, and Isotope information
#for all samples. This gives coverage values for a certain replicate, in a certain BD fraction, for a particular isotope treatment
#for all MAGs
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
abs_abundance = purr::map(abs_abundance, ~ dplyr::mutate(., Isotope = fractions$Isotope,
Fraction = fractions$Fraction,
Buoyant_density = fractions$Buoyant_density,
Rep = stringr::str_split_fixed(fractions$Sample, pattern = "_", n= Inf)[,3]))
)
#Summarise the mean abundance, standard deviation of abundance, and mean BD for each fraction and isotope treatment
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
summary_coverage = purr::map(abs_abundance, ~ dplyr::group_by(., Fraction, Isotope ) %>%
dplyr::summarise(mean_abs_abundance = mean(Abundance),
mean_BD = mean(Buoyant_density),
sd_abs_abundance = stats::sd(Abundance))),
summary_coverage = purr::map(summary_coverage, ~ dplyr::arrange(., Isotope))
)
#Plot abundance vs BD and save the plots in the current path
incorporator_abs_abundance = incorporator_abs_abundance %>%
dplyr::mutate(
plots = purr::map(summary_coverage, ~ ggplot2::ggplot(data = ., aes(x = mean_BD, y = mean_abs_abundance)) +
ggplot2::geom_point(aes(color = Isotope)) +
ggplot2::geom_line(aes(color = Isotope)) +
ggplot2::geom_errorbar(aes(ymin = mean_abs_abundance - sd_abs_abundance,
ymax = mean_abs_abundance + sd_abs_abundance)) +
ggplot2::ylab("Mean absolute \n abundance (attamole/uL)") +
ggplot2::xlab("Mean buoyant \n density (g/mL)") +
ggplot2::theme_bw()),
save_plots = purr::map2(plots, Feature,  ~ ggplot2::ggsave(filename = paste("mean_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/"))
)
#' View plots of abundance vs buoyant density for each replicate of the incorporators.
#' This could give a better visualization of anomalies, if any, present in the
#' abundance vs BD plots which may not be obvious in the mean and standard deviation estimates
incorporator_abs_abundance = incorporator_abs_abundance %>%
mutate(
plots_Rep1 = purr::map(abs_abundance, ~ dplyr::filter(., Rep == 1) %>%
ggplot2::ggplot(data = ., aes(x = Buoyant_density, y = Abundance)) +
ggplot2::geom_point(aes(color = Rep, shape = Isotope)) +
ggplot2::geom_line(aes(color = Isotope)) +
ggplot2::ylab("Absolute \n abundance (attamole/uL)") +
ggplot2::xlab("Buoyant \n density (g/mL)") +
ggplot2::theme_bw()),
plots_Rep2 = purr::map(abs_abundance, ~ dplyr::filter(., Rep == 2) %>%
ggplot2::ggplot(data = ., aes(x = Buoyant_density, y = Abundance)) +
ggplot2::geom_point(aes(color = Rep, shape = Isotope)) +
ggplot2::geom_line(aes(color = Isotope)) +
ggplot2::ylab("Absolute \n abundance (attamole/uL)") +
ggplot2::xlab("Buoyant \n density (g/mL)") +
ggplot2::theme_bw()),
plots_Rep3 = purr::map(abs_abundance, ~ dplyr::filter(., Rep == 3) %>%
ggplot2::ggplot(data = ., aes(x = Buoyant_density, y = Abundance)) +
ggplot2::geom_point(aes(color = Rep, shape = Isotope)) +
ggplot2::geom_line(aes(color = Isotope)) +
ggplot2::ylab("Absolute \n abundance (attamole/uL)") +
ggplot2::xlab("Buoyant \n density (g/mL)") +
ggplot2::theme_bw()),
save_plots = purr::map2(plots_Rep1, Feature,  ~ ggplot2::ggsave(filename = paste("Rep_1_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/")),
save_plots = purr::map2(plots_Rep2, Feature,  ~ ggplot2::ggsave(filename = paste("Rep_2_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/")),
save_plots = purr::map2(plots_Rep3, Feature,  ~ ggplot2::ggsave(filename = paste("Rep_3_abundance_",.y, ".pdf", sep=""), plot = .x, path = "abundance_plots/"))
)
}
?setNames()
?reduce()
?tibble()
?str_subset()
?tally()
?pull()
?min()
?lm()
?stat_regline_equation()
?strsplit
?column_to_rownames
column_to_rownames
?column_to_rownames()
as.matrix
devtools::load_all()
devtools::check()
devtools::check()
devtools::load_all()
library(roxygen2)
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::check()
devtools::load_all()
install.packages("margrittr")
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::check()
devtools::load_all()
devtools::check()
devtools::load_all()
devtools::check()
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::check()
devtools::load_all()
devtools::check()
devtools::load_all()
devtools::check()
devtools::load_all()
devtools::check()
devtools::load_all()
devtools::check()
devtools::load_all()
devtools::load_all()
devtools::check()
?qsipR::calc_atom_excess_MAGs()
?qsipR::incorporators_taxonomy()
magrittr::`%>%`
library(tidyverse)
library(roxygen2)
devtools::load_all(".")
library(qsipR)
devtools::load_all(".")
library(qsipR)
version()
R.Version()
library(qsipR)
library(qsipR)
library(qsipR)
.libPaths()
pkgbuild::find_rtools()
pkgbuild::find_rtools(debug = TRUE)
pkgbuild::has_rtools()
library(tidyverse)
library(readr)
fractions <- read_csv("~/GitHub/qSIP_metagenomics/mock_input_data/fractions.csv")
a = fractions %>%
filter(Isotope == "12C") %>%
group_by(Fraction) %>%
summarise(Wlight = mean(Buoyant_density))
View(a)
a = fractions %>%
filter(Isotope == "12C") %>%
group_by(Fraction) %>%
summarise(Wlight = mean(Buoyant_density)) %>%
select(-Fraction)
View(a)
?sd()
?mean()
?ggsave()
?pull()
?lm()
?summary()
?ggpubr::stat_regline_equation()
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
#Load required libraries
library(tidyverse)
library(phyloseq)
library(qsipR)
library(data.table)
library(ggpubr)
## Load data
#Coverage metadata
#Uncomment if your coverage data is in the format mentioned above for this file. Remains commented if you are using the output from `checkm coverage`
f_tibble = read_csv(file="../mock_input_data/coverage_metadata.csv")
#Sequins metadata
sequins <- read_csv(file="../mock_input_data/sequins_metadata.csv")
#Dilutions data
seq_dil = read_csv(file = "../mock_input_data/dilutions_data.csv")
#Log scale BOOLEAN. True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale
log_scale = TRUE
#coe_of_variation. Acceptable coefficient of variation for coverage and detection (eg. 20 - for 20 % threshold of coefficient of variation) (Coverages above the threshold value will be flagged in the plots)
coe_of_variation = 20
#Taxonomy
gtdbtk_bac_summary = read_delim("../mock_input_data/gtdbtk.bac120.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
gtdbtk_archaea = read_delim("../mock_input_data/gtdbtk.ar122.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
#GC content
GC_content <- read_csv(file = "../mock_input_data/GC_content.csv")
#Fractions
fractions_ps = read_csv("../mock_input_data/fractions.csv")
##Optional
#Bin data
#Use this line if you are using coverage data from `checkm coverage` program's output. Otherwise ensure your data is in the format specified for this pipeline and comment this next line
#bin_tibble = read_delim("../mock_input_data/checkm_coverage.tsv", "\t", escape_double = FALSE, trim_ws = TRUE)
#Operator
#operator = "mean"
taxonomy_ps = rbind(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if necessary
#Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
mag_tab_scaled <- scale_features_ps(f_tibble, sequins, seq_dil, log_scale, coe_of_variation)
#Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
mag_tab_scaled <- scale_features_ps(f_tibble, sequins, seq_dil, log_scale, coe_of_variation)
mag_tab = as.matrix(mag_tab_scaled$mag_tab) #Extract absolute abundances as a matrix
#mag_tab = as.matrix(mag_tab) #Ensuring input for phyloseq OTU table is in a matrix format
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
taxonomy.object = tax.table(taxonomy_ps) # Create a taxonomy phyloseq object
samples.object = sample.table(fractions_ps) # Create a samples phyloseq object
phylo.qSIP = phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
taxonomy.object = tax.table(taxonomy_ps) # Create a taxonomy phyloseq object
for(tax in seq_along(taxonomy_list)) {
taxonomy_list[[tax]] = unlist(strsplit(taxonomy$classification[[tax]], ";")) %>%
setdiff(., empties) %>%
utils::tail(., n = 1)
}
taxonomy_ps
tax.table.1 = function(taxonomy) {
classification = dplyr::select(taxonomy, classification) # Get rid of everything except taxonomy
empties = c("p__", "c__", "o__", "f__", "g__", "s__") #Create a list of prefixes for taxonomic classes to later extract them
taxonomy_list = rep(NA, length(taxonomy)) #Create an empty vector to run a for loop to extract taxonomy
for(tax in seq_along(taxonomy_list)) {
taxonomy_list[[tax]] = unlist(strsplit(taxonomy$classification[[tax]], ";")) %>%
setdiff(., empties) %>%
utils::tail(., n = 1)
}
taxonomy = taxonomy %>% #Using the loaded file for taxonomy, obtain just the Bin and taxonomic classification
# Later make the bins as row names to convert the object to a phyloseq-style taxonomy object
dplyr::mutate(taxa = taxonomy_list) %>%
dplyr::select(user_genome, taxa) %>%
tibble::column_to_rownames(var = "user_genome")
taxonomy = as.matrix(taxonomy) # Ensure the object is a matrix
tax.table = phyloseq::tax_table(taxonomy)
return(tax.table)
}
tax.table.1(taxonomy_ps)
classification.1 = select(taxonomy_ps, classification)
empties = c("p__", "c__", "o__", "f__", "g__", "s__") #Create a list of prefixes for taxonomic classes to later extract them
taxonomy_list = rep(NA, length(taxonomy_ps)) #Create an empty vector to run a for loop to extract taxonomy
taxonomy_list
classification.1
View(taxonomy_ps)
length(taxonomy_ps)
nrow(taxonomy_ps)
tax.table.1 = function(taxonomy) {
classification = dplyr::select(taxonomy, classification) # Get rid of everything except taxonomy
empties = c("p__", "c__", "o__", "f__", "g__", "s__") #Create a list of prefixes for taxonomic classes to later extract them
taxonomy_list = rep(NA, nrow(taxonomy)) #Create an empty vector to run a for loop to extract taxonomy
for(tax in seq_along(taxonomy_list)) {
taxonomy_list[[tax]] = unlist(strsplit(taxonomy$classification[[tax]], ";")) %>%
setdiff(., empties) %>%
utils::tail(., n = 1)
}
taxonomy = taxonomy %>% #Using the loaded file for taxonomy, obtain just the Bin and taxonomic classification
# Later make the bins as row names to convert the object to a phyloseq-style taxonomy object
dplyr::mutate(taxa = taxonomy_list) %>%
dplyr::select(user_genome, taxa) %>%
tibble::column_to_rownames(var = "user_genome")
taxonomy = as.matrix(taxonomy) # Ensure the object is a matrix
tax.table = phyloseq::tax_table(taxonomy)
return(tax.table)
}
tax.table.1(taxonomy_ps)
library(qsipR)
#mag_tab = as.matrix(mag_tab) #Ensuring input for phyloseq OTU table is in a matrix format
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
taxonomy.object = tax.table(taxonomy_ps) # Create a taxonomy phyloseq object
tax.table.2 = function(taxonomy) {
classification = dplyr::select(taxonomy, classification) # Get rid of everything except taxonomy
empties = c("p__", "c__", "o__", "f__", "g__", "s__") #Create a list of prefixes for taxonomic classes to later extract them
taxonomy_list = rep(NA, nrow(taxonomy)) #Create an empty vector to run a for loop to extract taxonomy
for(tax in seq_along(taxonomy_list)) {
taxonomy_list[[tax]] = unlist(strsplit(taxonomy$classification[[tax]], ";")) %>%
setdiff(., empties) %>%
utils::tail(., n = 1)
}
taxonomy = taxonomy %>% #Using the loaded file for taxonomy, obtain just the Bin and taxonomic classification
# Later make the bins as row names to convert the object to a phyloseq-style taxonomy object
dplyr::mutate(taxa = taxonomy_list) %>%
dplyr::select(user_genome, taxa) %>%
tibble::column_to_rownames(var = "user_genome")
taxonomy = as.matrix(taxonomy) # Ensure the object is a matrix
tax.table = phyloseq::tax_table(taxonomy)
return(tax.table)
}
tax.table.1(taxonomy_ps)
tax.table.2(taxonomy_ps)
library(qsipR)
taxonomy.object = tax.table(taxonomy_ps) # Create a taxonomy phyloseq object
qsipR::tax.table(taxonomy_ps)
taxonomy.object = tax.table.2(taxonomy_ps)
samples.object = sample.table(fractions_ps) # Create a samples phyloseq object
phylo.qSIP = phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
atomX = qSIP_atom_excess_MAGs(phylo.qSIP,
control_expr='Isotope=="12C"',
treatment_rep='Replicate',
Gi = GC_content)
library(qsipR)
atomX = qSIP_atom_excess_MAGs(phylo.qSIP,
control_expr='Isotope=="12C"',
treatment_rep='Replicate',
Gi = GC_content)
qsipR::qSIP_atom_excess_MAGs()
library(qsipR)
atomX = qSIP_atom_excess_MAGs(phylo.qSIP,
control_expr='Isotope=="12C"',
treatment_rep='Replicate',
Gi = GC_content)
atomX = qSIP_atom_excess_MAGs(phylo.qSIP,
control_expr='Isotope=="12C"',
treatment_rep='Replicate',
Gi = GC_content)
library(qsipR)
atomX = qSIP_atom_excess_MAGs(phylo.qSIP,
control_expr='Isotope=="12C"',
treatment_rep='Replicate',
Gi = GC_content)
a = HTSSIP::phyloseq2table(phylo.qSIP)
View(a)
tmp.1 = colnames(df_OTU)
tmp.1 = colnames(a)
a = a %>% dplyr::mutate_(Buoyant_density = "as.numeric(as.character(Buoyant_density))",
Count = "as.numeric(as.character(Count))") %>%
dplyr::filter_('! is.infinite(Buoyant_density)') %>%
dplyr::filter_('! is.na(Buoyant_density)') %>%
as.data.frame
colnames(df_OTU) = tmp
cols.1 = c('IS_CONTROL', 'Buoyant_density', treatment_rep)
#Load required libraries
library(tidyverse)
library(qsipR)
library(HTSSIP)
library(data.table)
library(ggpubr)
## Load data
#Coverage metadata
#Uncomment if your coverage data is in the format mentioned above for this file. Remains commented if you are using the output from `checkm coverage`
f_tibble = read_csv(file="mock_input_data/coverage_metadata.csv")
#Sequins metadata
sequins <- read_csv(file="mock_input_data/sequins_metadata.csv")
#Dilutions data
seq_dil = read_csv(file = "mock_input_data/dilutions_data.csv")
#Log scale BOOLEAN. True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale
log_scale = TRUE
#coe_of_variation. Acceptable coefficient of variation for coverage and detection (eg. 20 - for 20 % threshold of coefficient of variation) (Coverages above the threshold value will be flagged in the plots)
coe_of_variation = 20
#Taxonomy
gtdbtk_bac_summary = read_delim("mock_input_data/gtdbtk.bac120.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
gtdbtk_archaea = read_delim("mock_input_data/gtdbtk.ar122.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
#GC content
GC_content <- read_csv(file = "mock_input_data/GC_content.csv")
#Fractions
fractions_ps = read_csv("mock_input_data/fractions.csv")
##Optional
#Bin data
#Use this line if you are using coverage data from `checkm coverage` program's output. Otherwise ensure your data is in the format specified for this pipeline and comment this next line
#bin_tibble = read_delim("mock_input_data/checkm_coverage.tsv", "\t", escape_double = FALSE, trim_ws = TRUE)
#Operator
#operator = "mean"
taxonomy_ps = rbind(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if necessary
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration
#Optional coverage pooling and statistics
#Comment if your coverage data (f_tibble) is in the format specified for this pipeline. Use this line if you are using the coverage file from `checkm coverage` program's output
#f_tibble = pool_bin_stat(bin_tibble)
#Save the output file
#write.csv(f_tibble, "pool_bin_stat.csv", row.names = F)
#Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
mag_tab_scaled <- scale_features_ps(f_tibble, sequins, seq_dil, log_scale, coe_of_variation)
mag_tab = as.matrix(mag_tab_scaled$mag_tab) #Extract absolute abundances as a matrix
#mag_tab = as.matrix(mag_tab) #Ensuring input for phyloseq OTU table is in a matrix format
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
taxonomy.object = tax.table(taxonomy_ps) # Create a taxonomy phyloseq object
samples.object = sample.table(fractions_ps) # Create a samples phyloseq object
phylo.qSIP = phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
```
Calculate atom fraction excess. By bootstrapping confidence intervals, determine incorporators
```{r Calculate atom fraction excess}
atomX = qSIP_atom_excess_MAGs(phylo.qSIP,
control_expr='Isotope=="12C"',
treatment_rep='Replicate',
Gi = GC_content)
#Bootstrap confidence intervals
df_atomX_boot = qSIP_bootstrap(atomX, n_boot=100)
df_atomX_boot %>% head
CI_threshold = 0
df_atomX_boot = df_atomX_boot %>%
mutate(Incorporator = A_CI_low > CI_threshold,
OTU = reorder(OTU, -A))
#Get incorporator info
n_incorp = df_atomX_boot %>%
filter(Incorporator == TRUE) %>%
nrow
#Get incorporator list
incorporator_list = incorporators_taxonomy(taxonomy = taxonomy_ps, bootstrapped_AFE_table = df_atomX_boot)
#Print incorporator information
cat('Number of incorporators:', n_incorp, '\n')
cat('Incorporators: \n')
incorporator_list
```
Plot the atom fraction excess plot
```{r Plot atom fraction excess}
(atom_f_excess_plot = ggplot(df_atomX_boot, aes(OTU, A, ymin=A_CI_low, ymax=A_CI_high, color=Incorporator)) +
geom_pointrange(size=0.25) +
geom_linerange() +
geom_hline(yintercept=0, linetype='dashed', alpha=0.5) +
labs(x='MAGs', y='Atom fraction excess') +
theme_bw() +
coord_flip() +
ggtitle("Isotope incorporating MAGs"))
ggsave(filename = "atom_fration_excess.pdf", plot = atom_f_excess_plot, path = "mock_output_data")
```
## Optional workflow to view abundance vs BD plots of incorporators
This is an optional workflow that outputs plots with mean and standard deviation of abundance and mean buoyant density across the replicates for the incorporators. The plots are saved in the folder "abundance_plots" in the current directory
#Input parameters
- incorporator_list - A tibble of incorporators and their taxonomy as obtained from the previous steps of the markdown
- fractions - The same fractions metadata file as loaded previously
- mag_tab - MAG abundance estimates calculated from the `sequin_scaling.R` function in this markdown
```{r Optional abundance plots}
#Load function for abundance plots
source("Functions/abundance_plots.R")
plot_abundance(incorporator_list = incorporator_list, fractions = fractions, mag_tab = mag_tab)
phylo.qSIP = phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
#Load required libraries
library(tidyverse)
library(qsipR)
#library(HTSSIP)
library(data.table)
library(ggpubr)
## Load data
#Coverage metadata
#Uncomment if your coverage data is in the format mentioned above for this file. Remains commented if you are using the output from `checkm coverage`
f_tibble = read_csv(file="mock_input_data/coverage_metadata.csv")
#Sequins metadata
sequins <- read_csv(file="mock_input_data/sequins_metadata.csv")
#Dilutions data
seq_dil = read_csv(file = "mock_input_data/dilutions_data.csv")
#Log scale BOOLEAN. True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale
log_scale = TRUE
#coe_of_variation. Acceptable coefficient of variation for coverage and detection (eg. 20 - for 20 % threshold of coefficient of variation) (Coverages above the threshold value will be flagged in the plots)
coe_of_variation = 20
#Taxonomy
gtdbtk_bac_summary = read_delim("mock_input_data/gtdbtk.bac120.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
gtdbtk_archaea = read_delim("mock_input_data/gtdbtk.ar122.summary.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
#GC content
GC_content <- read_csv(file = "mock_input_data/GC_content.csv")
#Fractions
fractions_ps = read_csv("mock_input_data/fractions.csv")
##Optional
#Bin data
#Use this line if you are using coverage data from `checkm coverage` program's output. Otherwise ensure your data is in the format specified for this pipeline and comment this next line
#bin_tibble = read_delim("mock_input_data/checkm_coverage.tsv", "\t", escape_double = FALSE, trim_ws = TRUE)
#Operator
#operator = "mean"
taxonomy_ps = rbind(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if necessary
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration
#Optional coverage pooling and statistics
#Comment if your coverage data (f_tibble) is in the format specified for this pipeline. Use this line if you are using the coverage file from `checkm coverage` program's output
#f_tibble = pool_bin_stat(bin_tibble)
#Save the output file
#write.csv(f_tibble, "pool_bin_stat.csv", row.names = F)
#Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
mag_tab_scaled <- scale_features_ps(f_tibble, sequins, seq_dil, log_scale, coe_of_variation)
mag_tab = as.matrix(mag_tab_scaled$mag_tab) #Extract absolute abundances as a matrix
#mag_tab = as.matrix(mag_tab) #Ensuring input for phyloseq OTU table is in a matrix format
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table
taxonomy.object = tax.table(taxonomy_ps) # Create a taxonomy phyloseq object
samples.object = sample.table(fractions_ps) # Create a samples phyloseq object
phylo.qSIP = phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis
atomX = qSIP_atom_excess_MAGs(phylo.qSIP,
control_expr='Isotope=="12C"',
treatment_rep='Replicate',
Gi = GC_content)
#Bootstrap confidence intervals
df_atomX_boot = qSIP_bootstrap(atomX, n_boot=100)
df_atomX_boot %>% head
CI_threshold = 0
df_atomX_boot = df_atomX_boot %>%
mutate(Incorporator = A_CI_low > CI_threshold,
OTU = reorder(OTU, -A))
#Get incorporator info
n_incorp = df_atomX_boot %>%
filter(Incorporator == TRUE) %>%
nrow
#Get incorporator list
incorporator_list = incorporators_taxonomy(taxonomy = taxonomy_ps, bootstrapped_AFE_table = df_atomX_boot)
#Print incorporator information
cat('Number of incorporators:', n_incorp, '\n')
cat('Incorporators: \n')
incorporator_list
(atom_f_excess_plot = ggplot(df_atomX_boot, aes(OTU, A, ymin=A_CI_low, ymax=A_CI_high, color=Incorporator)) +
geom_pointrange(size=0.25) +
geom_linerange() +
geom_hline(yintercept=0, linetype='dashed', alpha=0.5) +
labs(x='MAGs', y='Atom fraction excess') +
theme_bw() +
coord_flip() +
ggtitle("Isotope incorporating MAGs"))
ggsave(filename = "atom_fration_excess.pdf", plot = atom_f_excess_plot, path = "mock_output_data")
plot_abundance(incorporator_list = incorporator_list, fractions = fractions, mag_tab = mag_tab)
plot_abundance(incorporator_list = incorporator_list, fractions = fractions_ps, mag_tab = mag_tab)
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
?qSIPmg::scale_features()
library(qSIPmg)
?qSIPmg::scale_features()
library(qSIPmg)
?qSIPmg::scale_features()
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
library(qSIPmg)
